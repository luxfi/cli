// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/z/go/pkg/mod/github.com/!data!dog/zstd@v1.5.7/zstd_ctx.go:1:1
package zstd

/*
#include "zstd.h"
*/
import _ "unsafe"
import (
	"bytes"
	"io/ioutil"
	"runtime"
	"unsafe"
)

type Ctx interface {
	// Compress src into dst.  If you have a buffer to use, you can pass it to
	// prevent allocation.  If it is too small, or if nil is passed, a new buffer
	// will be allocated and returned.
	Compress(dst, src []byte) ([]byte, error)

	// CompressLevel is the same as Compress but you can pass a compression level
	CompressLevel(dst, src []byte, level int) ([]byte, error)

	// Decompress src into dst.  If you have a buffer to use, you can pass it to
	// prevent allocation.  If it is too small, or if nil is passed, a new buffer
	// will be allocated and returned.
	Decompress(dst, src []byte) ([]byte, error)

	// DecompressInto decompresses src into dst. Unlike Decompress, DecompressInto
	// requires that dst be sufficiently large to hold the decompressed payload.
	// DecompressInto may be used when the caller knows the size of the decompressed
	// payload before attempting decompression.
	//
	// It returns the number of bytes copied and an error if any is encountered. If
	// dst is too small, DecompressInto errors.
	DecompressInto(dst, src []byte) (int, error)
}

type ctx struct {
	cctx * /*line :39:8*/_Ctype_ZSTD_CCtx /*line :39:19*/
	dctx * /*line :40:8*/_Ctype_ZSTD_DCtx /*line :40:19*/
}

// Create a new ZStd Context.
//  When compressing/decompressing many times, it is recommended to allocate a
//  context just once, and re-use it for each successive compression operation.
//  This will make workload friendlier for system's memory.
//  Note : re-using context is just a speed / resource optimization.
//         It doesn't change the compression ratio, which remains identical.
//  Note 2 : In multi-threaded environments,
//         use one different context per thread for parallel execution.
//
func NewCtx() Ctx {
	c := &ctx{
		cctx: ( /*line :54:9*/_Cfunc_ZSTD_createCCtx /*line :54:25*/)(),
		dctx: ( /*line :55:9*/_Cfunc_ZSTD_createDCtx /*line :55:25*/)(),
	}

	runtime.SetFinalizer(c, finalizeCtx)
	return c
}

func (c *ctx) Compress(dst, src []byte) ([]byte, error) {
	return c.CompressLevel(dst, src, DefaultCompression)
}

func (c *ctx) CompressLevel(dst, src []byte, level int) ([]byte, error) {
	bound := CompressBound(len(src))
	if cap(dst) >= bound {
		dst = dst[0:bound] // Reuse dst buffer
	} else {
		dst = make([]byte, bound)
	}

	// We need unsafe.Pointer(&src[0]) in the Cgo call to avoid "Go pointer to Go pointer" panics.
	// This means we need to special case empty input. See:
	// https://github.com/golang/go/issues/14210#issuecomment-346402945
	var cWritten  /*line :77:15*/_Ctype_size_t /*line :77:23*/
	if len(src) == 0 {
		cWritten = func() _Ctype_size_t{ _cgo0 := /*line :80:4*/c.cctx; _cgoIndex1 := &/*line :81:20*/dst; _cgo1 := /*line :81:4*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :82:12*/(len(dst)); _cgo3 := /*line :83:4*/unsafe.Pointer(nil); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :84:12*/(0); var _cgo5 _Ctype_int = _Ctype_int /*line :85:9*/(level); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo3, nil); return /*line :85:17*/_Cfunc_ZSTD_compressCCtx(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	} else {
		cWritten = func() _Ctype_size_t{ _cgo0 := /*line :88:4*/c.cctx; _cgoIndex1 := &/*line :89:20*/dst; _cgo1 := /*line :89:4*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :90:12*/(len(dst)); _cgoIndex3 := &/*line :91:20*/src; _cgo3 := /*line :91:4*/unsafe.Pointer(&(*_cgoIndex3)[0]); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :92:12*/(len(src)); var _cgo5 _Ctype_int = _Ctype_int /*line :93:9*/(level); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo3, *_cgoIndex3); return /*line :93:17*/_Cfunc_ZSTD_compressCCtx(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	}

	written := int(cWritten)
	// Check if the return is an Error code
	if err := getError(written); err != nil {
		return nil, err
	}
	return dst[:written], nil
}

func (c *ctx) Decompress(dst, src []byte) ([]byte, error) {
	if len(src) == 0 {
		return []byte{}, ErrEmptySlice
	}

	bound := decompressSizeHint(src)
	if cap(dst) >= bound {
		dst = dst[0:cap(dst)]
	} else {
		dst = make([]byte, bound)
	}

	written, err := c.DecompressInto(dst, src)
	if err == nil {
		return dst[:written], nil
	}
	if !IsDstSizeTooSmallError(err) {
		return nil, err
	}

	// We failed getting a dst buffer of correct size, use stream API
	r := NewReader(bytes.NewReader(src))
	defer r.Close()
	return ioutil.ReadAll(r)
}

func (c *ctx) DecompressInto(dst, src []byte) (int, error) {
	written := int(func() _Ctype_size_t{ _cgo0 := /*line :132:3*/c.dctx; _cgoIndex1 := &/*line :133:19*/dst; _cgo1 := /*line :133:3*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :134:11*/(len(dst)); _cgoIndex3 := &/*line :135:19*/src; _cgo3 := /*line :135:3*/unsafe.Pointer(&(*_cgoIndex3)[0]); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :136:11*/(len(src)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo3, *_cgoIndex3); return /*line :136:22*/_Cfunc_ZSTD_decompressDCtx(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }())
	err := getError(written)
	return written, err
}

func finalizeCtx(c *ctx) {
	func() _Ctype_size_t{ _cgo0 := /*line :142:18*/c.cctx; _cgoCheckPointer(_cgo0, nil); return /*line :142:25*/_Cfunc_ZSTD_freeCCtx(_cgo0); }()
	func() _Ctype_size_t{ _cgo0 := /*line :143:18*/c.dctx; _cgoCheckPointer(_cgo0, nil); return /*line :143:25*/_Cfunc_ZSTD_freeDCtx(_cgo0); }()
}

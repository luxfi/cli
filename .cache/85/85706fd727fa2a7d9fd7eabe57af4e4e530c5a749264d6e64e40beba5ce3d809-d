// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/z/go/pkg/mod/github.com/ethereum/go-ethereum@v1.16.1/crypto/secp256k1/secp256.go:1:1
// Copyright 2015 Jeffrey Wilcke, Felix Lange, Gustav Simonsson. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

//go:build !gofuzz && cgo
// +build !gofuzz,cgo

// Package secp256k1 wraps the bitcoin secp256k1 C library.
package secp256k1; import _cgo_unsafe "unsafe"

/*
#cgo CFLAGS: -I./libsecp256k1
#cgo CFLAGS: -I./libsecp256k1/src/

#ifndef NDEBUG
#  define NDEBUG
#endif

#include "./libsecp256k1/src/secp256k1.c"
#include "./libsecp256k1/src/modules/recovery/main_impl.h"
#include "./libsecp256k1/src/precomputed_ecmult.c"
#include "./libsecp256k1/src/precomputed_ecmult_gen.c"
#include "ext.h"

typedef void (*callbackFunc) (const char* msg, void* data);
extern void secp256k1GoPanicIllegal(const char* msg, void* data);
extern void secp256k1GoPanicError(const char* msg, void* data);
*/
import _ "unsafe"

import (
	"errors"
	"math/big"
	"unsafe"
)

var context * /*line :37:14*/_Ctype_secp256k1_context /*line :37:33*/

func init() {
	// around 20 ms on a modern CPU.
	context = ( /*line :41:12*/_Cfunc_secp256k1_context_create_sign_verify /*line :41:49*/)()
	func() { _cgo0 := /*line :42:43*/context; var _cgo1 *[0]byte = _Ctype_callbackFunc /*line :42:66*/(_Cgo_ptr(_Cfpvar_fp_secp256k1GoPanicIllegal /*line :42:92*/)); var _cgo2 _cgo_unsafe.Pointer = /*line :42:95*/nil; _cgoCheckPointer(_cgo0, nil); /*line :42:99*/_Cfunc_secp256k1_context_set_illegal_callback(_cgo0, _cgo1, _cgo2); }()
	func() { _cgo0 := /*line :43:41*/context; var _cgo1 *[0]byte = _Ctype_callbackFunc /*line :43:64*/(_Cgo_ptr(_Cfpvar_fp_secp256k1GoPanicError /*line :43:88*/)); var _cgo2 _cgo_unsafe.Pointer = /*line :43:91*/nil; _cgoCheckPointer(_cgo0, nil); /*line :43:95*/_Cfunc_secp256k1_context_set_error_callback(_cgo0, _cgo1, _cgo2); }()
}

var (
	ErrInvalidMsgLen       = errors.New("invalid message length, need 32 bytes")
	ErrInvalidSignatureLen = errors.New("invalid signature length")
	ErrInvalidRecoveryID   = errors.New("invalid signature recovery id")
	ErrInvalidKey          = errors.New("invalid private key")
	ErrInvalidPubkey       = errors.New("invalid public key")
	ErrSignFailed          = errors.New("signing failed")
	ErrRecoverFailed       = errors.New("recovery failed")
)

// Sign creates a recoverable ECDSA signature.
// The produced signature is in the 65-byte [R || S || V] format where V is 0 or 1.
//
// The caller is responsible for ensuring that msg cannot be chosen
// directly by an attacker. It is usually preferable to use a cryptographic
// hash function on any input before handing it to this function.
func Sign(msg []byte, seckey []byte) ([]byte, error) {
	if len(msg) != 32 {
		return nil, ErrInvalidMsgLen
	}
	if len(seckey) != 32 {
		return nil, ErrInvalidKey
	}
	seckeydata := (* /*line :69:18*/_Ctype_uchar /*line :69:25*/)(unsafe.Pointer(&seckey[0]))
	if func() _Ctype_int{ _cgo0 := /*line :70:34*/context; var _cgo1 *_Ctype_uchar = /*line :70:43*/seckeydata; _cgoCheckPointer(_cgo0, nil); return /*line :70:54*/_Cfunc_secp256k1_ec_seckey_verify(_cgo0, _cgo1); }() != 1 {
		return nil, ErrInvalidKey
	}

	var (
		msgdata   = (* /*line :75:17*/_Ctype_uchar /*line :75:24*/)(unsafe.Pointer(&msg[0]))
		noncefunc = ( /*line :76:15*/*_Cvar_secp256k1_nonce_function_rfc6979 /*line :76:48*/)
		sigstruct  /*line :77:13*/_Ctype_secp256k1_ecdsa_recoverable_signature /*line :77:52*/
	)
	if func() _Ctype_int{ _cgo0 := /*line :79:40*/context; var _cgo1 *_Ctype_struct_secp256k1_ecdsa_recoverable_signature = /*line :79:49*/&sigstruct; var _cgo2 *_Ctype_uchar = /*line :79:61*/msgdata; var _cgo3 *_Ctype_uchar = /*line :79:70*/seckeydata; var _cgo4 *[0]byte = /*line :79:82*/noncefunc; var _cgo5 _cgo_unsafe.Pointer = /*line :79:93*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :79:97*/_Cfunc_secp256k1_ecdsa_sign_recoverable(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }() == 0 {
		return nil, ErrSignFailed
	}

	var (
		sig     = make([]byte, 65)
		sigdata = (* /*line :85:15*/_Ctype_uchar /*line :85:22*/)(unsafe.Pointer(&sig[0]))
		recid    /*line :86:11*/_Ctype_int /*line :86:16*/
	)
	func() _Ctype_int{ _cgo0 := /*line :88:60*/context; var _cgo1 *_Ctype_uchar = /*line :88:69*/sigdata; var _cgo2 *_Ctype_int = /*line :88:78*/&recid; var _cgo3 *_Ctype_struct_secp256k1_ecdsa_recoverable_signature = /*line :88:86*/&sigstruct; _cgoCheckPointer(_cgo0, nil); return /*line :88:97*/_Cfunc_secp256k1_ecdsa_recoverable_signature_serialize_compact(_cgo0, _cgo1, _cgo2, _cgo3); }()
	sig[64] = byte(recid) // add back recid to get 65 bytes sig
	return sig, nil
}

// RecoverPubkey returns the public key of the signer.
// msg must be the 32-byte hash of the message to be signed.
// sig must be a 65-byte compact ECDSA signature containing the
// recovery id as the last element.
func RecoverPubkey(msg []byte, sig []byte) ([]byte, error) {
	if len(msg) != 32 {
		return nil, ErrInvalidMsgLen
	}
	if err := checkSignature(sig); err != nil {
		return nil, err
	}

	var (
		pubkey  = make([]byte, 65)
		sigdata = (* /*line :107:15*/_Ctype_uchar /*line :107:22*/)(unsafe.Pointer(&sig[0]))
		msgdata = (* /*line :108:15*/_Ctype_uchar /*line :108:22*/)(unsafe.Pointer(&msg[0]))
	)
	if func() _Ctype_int{ _cgo0 := /*line :110:35*/context; var _cgo1 *_Ctype_uchar = /*line :110:44*/(*_Ctype_uchar /*line :110:53*/)(unsafe.Pointer(&pubkey[0])); var _cgo2 *_Ctype_uchar = /*line :110:84*/sigdata; var _cgo3 *_Ctype_uchar = /*line :110:93*/msgdata; _cgoCheckPointer(_cgo0, nil); return /*line :110:101*/_Cfunc_secp256k1_ext_ecdsa_recover(_cgo0, _cgo1, _cgo2, _cgo3); }() == 0 {
		return nil, ErrRecoverFailed
	}
	return pubkey, nil
}

// VerifySignature checks that the given pubkey created signature over message.
// The signature should be in [R || S] format.
func VerifySignature(pubkey, msg, signature []byte) bool {
	if len(msg) != 32 || len(signature) != 64 || len(pubkey) == 0 {
		return false
	}
	sigdata := (* /*line :122:15*/_Ctype_uchar /*line :122:22*/)(unsafe.Pointer(&signature[0]))
	msgdata := (* /*line :123:15*/_Ctype_uchar /*line :123:22*/)(unsafe.Pointer(&msg[0]))
	keydata := (* /*line :124:15*/_Ctype_uchar /*line :124:22*/)(unsafe.Pointer(&pubkey[0]))
	return func() _Ctype_int{ _cgo0 := /*line :125:38*/context; var _cgo1 *_Ctype_uchar = /*line :125:47*/sigdata; var _cgo2 *_Ctype_uchar = /*line :125:56*/msgdata; var _cgo3 *_Ctype_uchar = /*line :125:65*/keydata; var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :125:82*/(len(pubkey)); _cgoCheckPointer(_cgo0, nil); return /*line :125:96*/_Cfunc_secp256k1_ext_ecdsa_verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() != 0
}

// DecompressPubkey parses a public key in the 33-byte compressed format.
// It returns non-nil coordinates if the public key is valid.
func DecompressPubkey(pubkey []byte) (x, y *big.Int) {
	if len(pubkey) != 33 {
		return nil, nil
	}
	var (
		pubkeydata = (* /*line :135:18*/_Ctype_uchar /*line :135:25*/)(unsafe.Pointer(&pubkey[0]))
		pubkeylen  =  /*line :136:16*/_Ctype_size_t /*line :136:24*/(len(pubkey))
		out        = make([]byte, 65)
		outdata    = (* /*line :138:18*/_Ctype_uchar /*line :138:25*/)(unsafe.Pointer(&out[0]))
		outlen     =  /*line :139:16*/_Ctype_size_t /*line :139:24*/(len(out))
	)
	if func() _Ctype_int{ _cgo0 := /*line :141:37*/context; var _cgo1 *_Ctype_uchar = /*line :141:46*/outdata; var _cgo2 _Ctype_size_t = /*line :141:55*/outlen; var _cgo3 *_Ctype_uchar = /*line :141:63*/pubkeydata; var _cgo4 _Ctype_size_t = /*line :141:75*/pubkeylen; _cgoCheckPointer(_cgo0, nil); return /*line :141:85*/_Cfunc_secp256k1_ext_reencode_pubkey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		return nil, nil
	}
	return new(big.Int).SetBytes(out[1:33]), new(big.Int).SetBytes(out[33:])
}

// CompressPubkey encodes a public key to 33-byte compressed format.
func CompressPubkey(x, y *big.Int) []byte {
	var (
		pubkey     = S256().Marshal(x, y)
		pubkeydata = (* /*line :151:18*/_Ctype_uchar /*line :151:25*/)(unsafe.Pointer(&pubkey[0]))
		pubkeylen  =  /*line :152:16*/_Ctype_size_t /*line :152:24*/(len(pubkey))
		out        = make([]byte, 33)
		outdata    = (* /*line :154:18*/_Ctype_uchar /*line :154:25*/)(unsafe.Pointer(&out[0]))
		outlen     =  /*line :155:16*/_Ctype_size_t /*line :155:24*/(len(out))
	)
	if func() _Ctype_int{ _cgo0 := /*line :157:37*/context; var _cgo1 *_Ctype_uchar = /*line :157:46*/outdata; var _cgo2 _Ctype_size_t = /*line :157:55*/outlen; var _cgo3 *_Ctype_uchar = /*line :157:63*/pubkeydata; var _cgo4 _Ctype_size_t = /*line :157:75*/pubkeylen; _cgoCheckPointer(_cgo0, nil); return /*line :157:85*/_Cfunc_secp256k1_ext_reencode_pubkey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 0 {
		panic("libsecp256k1 error")
	}
	return out
}

func checkSignature(sig []byte) error {
	if len(sig) != 65 {
		return ErrInvalidSignatureLen
	}
	if sig[64] >= 4 {
		return ErrInvalidRecoveryID
	}
	return nil
}

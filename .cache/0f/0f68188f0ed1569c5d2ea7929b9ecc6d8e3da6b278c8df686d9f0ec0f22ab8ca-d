// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/z/go/pkg/mod/github.com/!data!dog/zstd@v1.5.7/zstd_bulk.go:1:1
package zstd

/*
#include "zstd.h"
*/
import _ "unsafe"
import (
	"errors"
	"runtime"
	"unsafe"
)

var (
	// ErrEmptyDictionary is returned when the given dictionary is empty
	ErrEmptyDictionary = errors.New("Dictionary is empty")
	// ErrBadDictionary is returned when cannot load the given dictionary
	ErrBadDictionary = errors.New("Cannot load dictionary")
)

// BulkProcessor implements Bulk processing dictionary API.
// When compressing multiple messages or blocks using the same dictionary,
// it's recommended to digest the dictionary only once, since it's a costly operation.
// NewBulkProcessor() will create a state from digesting a dictionary.
// The resulting state can be used for future compression/decompression operations with very limited startup cost.
// BulkProcessor can be created once and shared by multiple threads concurrently, since its usage is read-only.
// The state will be freed when gc cleans up BulkProcessor.
type BulkProcessor struct {
	cDict * /*line :28:9*/_Ctype_struct_ZSTD_CDict_s /*line :28:30*/
	dDict * /*line :29:9*/_Ctype_struct_ZSTD_DDict_s /*line :29:30*/
}

// NewBulkProcessor creates a new BulkProcessor with a pre-trained dictionary and compression level
func NewBulkProcessor(dictionary []byte, compressionLevel int) (*BulkProcessor, error) {
	if len(dictionary) < 1 {
		return nil, ErrEmptyDictionary
	}

	p := &BulkProcessor{}
	runtime.SetFinalizer(p, finalizeBulkProcessor)

	p.cDict = func() *_Ctype_struct_ZSTD_CDict_s{ _cgoIndex0 := &/*line :42:19*/dictionary; _cgo0 := /*line :42:3*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :43:11*/(len(dictionary)); var _cgo2 _Ctype_int = _Ctype_int /*line :44:8*/(compressionLevel); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :45:3*/_Cfunc_ZSTD_createCDict(_cgo0, _cgo1, _cgo2); }()
	if p.cDict == nil {
		return nil, ErrBadDictionary
	}
	p.dDict = func() *_Ctype_struct_ZSTD_DDict_s{ _cgoIndex0 := &/*line :50:19*/dictionary; _cgo0 := /*line :50:3*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :51:11*/(len(dictionary)); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :52:3*/_Cfunc_ZSTD_createDDict(_cgo0, _cgo1); }()
	if p.dDict == nil {
		return nil, ErrBadDictionary
	}

	return p, nil
}

// Compress compresses `src` into `dst` with the dictionary given when creating the BulkProcessor.
// If you have a buffer to use, you can pass it to prevent allocation.
// If it is too small, or if nil is passed, a new buffer will be allocated and returned.
func (p *BulkProcessor) Compress(dst, src []byte) ([]byte, error) {
	bound := CompressBound(len(src))
	if cap(dst) >= bound {
		dst = dst[0:bound]
	} else {
		dst = make([]byte, bound)
	}

	cctx := ( /*line :71:10*/_Cfunc_ZSTD_createCCtx /*line :71:26*/)()
	// We need unsafe.Pointer(&src[0]) in the Cgo call to avoid "Go pointer to Go pointer" panics.
	// This means we need to special case empty input. See:
	// https://github.com/golang/go/issues/14210#issuecomment-346402945
	var cWritten  /*line :75:15*/_Ctype_size_t /*line :75:23*/
	if len(src) == 0 {
		cWritten = func() _Ctype_size_t{ _cgo0 := /*line :78:4*/cctx; _cgoIndex1 := &/*line :79:20*/dst; _cgo1 := /*line :79:4*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :80:12*/(len(dst)); _cgo3 := /*line :81:4*/unsafe.Pointer(nil); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :82:12*/(len(src)); _cgo5 := /*line :83:4*/p.cDict; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo5, nil); return /*line :84:4*/_Cfunc_ZSTD_compress_usingCDict(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	} else {
		cWritten = func() _Ctype_size_t{ _cgo0 := /*line :87:4*/cctx; _cgoIndex1 := &/*line :88:20*/dst; _cgo1 := /*line :88:4*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :89:12*/(len(dst)); _cgoIndex3 := &/*line :90:20*/src; _cgo3 := /*line :90:4*/unsafe.Pointer(&(*_cgoIndex3)[0]); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :91:12*/(len(src)); _cgo5 := /*line :92:4*/p.cDict; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo3, *_cgoIndex3); _cgoCheckPointer(_cgo5, nil); return /*line :93:4*/_Cfunc_ZSTD_compress_usingCDict(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	}

	func() _Ctype_size_t{ _cgo0 := /*line :96:18*/cctx; _cgoCheckPointer(_cgo0, nil); return /*line :96:23*/_Cfunc_ZSTD_freeCCtx(_cgo0); }()

	written := int(cWritten)
	if err := getError(written); err != nil {
		return nil, err
	}
	return dst[:written], nil
}

// Decompress decompresses `src` into `dst` with the dictionary given when creating the BulkProcessor.
// If you have a buffer to use, you can pass it to prevent allocation.
// If it is too small, or if nil is passed, a new buffer will be allocated and returned.
func (p *BulkProcessor) Decompress(dst, src []byte) ([]byte, error) {
	if len(src) == 0 {
		return nil, ErrEmptySlice
	}

	contentSize := decompressSizeHint(src)
	if cap(dst) >= contentSize {
		dst = dst[0:cap(dst)]
	} else {
		dst = make([]byte, contentSize)
	}

	if len(dst) == 0 {
		return dst, nil
	}

	dctx := ( /*line :124:10*/_Cfunc_ZSTD_createDCtx /*line :124:26*/)()
	cWritten := func() _Ctype_size_t{ _cgo0 := /*line :126:3*/dctx; _cgoIndex1 := &/*line :127:19*/dst; _cgo1 := /*line :127:3*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :128:11*/(len(dst)); _cgoIndex3 := &/*line :129:19*/src; _cgo3 := /*line :129:3*/unsafe.Pointer(&(*_cgoIndex3)[0]); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :130:11*/(len(src)); _cgo5 := /*line :131:3*/p.dDict; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo3, *_cgoIndex3); _cgoCheckPointer(_cgo5, nil); return /*line :132:3*/_Cfunc_ZSTD_decompress_usingDDict(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	func() _Ctype_size_t{ _cgo0 := /*line :133:18*/dctx; _cgoCheckPointer(_cgo0, nil); return /*line :133:23*/_Cfunc_ZSTD_freeDCtx(_cgo0); }()

	written := int(cWritten)
	if err := getError(written); err != nil {
		return nil, err
	}

	return dst[:written], nil
}

// finalizeBulkProcessor frees compression and decompression dictionaries from memory
func finalizeBulkProcessor(p *BulkProcessor) {
	if p.cDict != nil {
		func() _Ctype_size_t{ _cgo0 := /*line :146:20*/p.cDict; _cgoCheckPointer(_cgo0, nil); return /*line :146:28*/_Cfunc_ZSTD_freeCDict(_cgo0); }()
	}
	if p.dDict != nil {
		func() _Ctype_size_t{ _cgo0 := /*line :149:20*/p.dDict; _cgoCheckPointer(_cgo0, nil); return /*line :149:28*/_Cfunc_ZSTD_freeDDict(_cgo0); }()
	}
}

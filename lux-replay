#!/usr/bin/env bash
# lux-replay - CLI wrapper for managing C-Chain replay operations
# Usage: lux-replay [run|status|stop|resume] [options]

set -e

# Default configuration
DEFAULT_RPC="http://localhost:9630/ext/bc/C/rpc"
DEFAULT_SOURCE_RPC="http://localhost:9631/ext/bc/legacy/rpc"
DEFAULT_CHECKPOINT_DIR="/var/lib/lux/replay/96369"
DEFAULT_CHAIN_ID=96369

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Show usage
show_usage() {
    cat <<EOF
LUX Replay CLI - Manage C-Chain block replay from legacy SubnetEVM

Usage: lux-replay [command] [options]

Commands:
    run       Start a new replay operation
    status    Check current replay status
    stop      Stop the running replay
    resume    Resume from last checkpoint
    verify    Verify replayed blocks against legacy

Options:
    --rpc URL           C-Chain RPC endpoint (default: $DEFAULT_RPC)
    --source URL        Legacy chain RPC endpoint (default: $DEFAULT_SOURCE_RPC)
    --from BLOCK        Starting block number (hex or decimal)
    --to BLOCK          Ending block number (hex or decimal, default: 0x106978)
    --checkpoint N      Checkpoint every N blocks (default: 10000)
    --workers N         Number of receipt workers (default: 32)
    --verify-receipts   Enable receipt verification (default: true)
    --strict-state      Enable strict state root checking (default: true)
    --tail              Follow replay progress (for 'run' command)
    --json              Output in JSON format

Examples:
    lux-replay run --from 0x1 --to 0x106978 --tail
    lux-replay status --json
    lux-replay resume --tail
    lux-replay verify --from 0x100000 --to 0x100100

EOF
    exit 0
}

# Parse command line arguments
parse_args() {
    COMMAND="${1:-}"
    shift || true

    # Set defaults
    RPC="$DEFAULT_RPC"
    SOURCE_RPC="$DEFAULT_SOURCE_RPC"
    FROM_BLOCK="0x1"
    TO_BLOCK="0x106978"  # 1,074,616 in hex
    CHECKPOINT_EVERY=10000
    RECEIPT_WORKERS=32
    VERIFY_RECEIPTS=true
    STRICT_STATE=true
    TAIL=false
    JSON_OUTPUT=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --rpc)
                RPC="$2"
                shift 2
                ;;
            --source)
                SOURCE_RPC="$2"
                shift 2
                ;;
            --from)
                FROM_BLOCK="$2"
                shift 2
                ;;
            --to)
                TO_BLOCK="$2"
                shift 2
                ;;
            --checkpoint)
                CHECKPOINT_EVERY="$2"
                shift 2
                ;;
            --workers)
                RECEIPT_WORKERS="$2"
                shift 2
                ;;
            --verify-receipts)
                VERIFY_RECEIPTS=true
                shift
                ;;
            --no-verify-receipts)
                VERIFY_RECEIPTS=false
                shift
                ;;
            --strict-state)
                STRICT_STATE=true
                shift
                ;;
            --no-strict-state)
                STRICT_STATE=false
                shift
                ;;
            --tail)
                TAIL=true
                shift
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --help|-h)
                show_usage
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                ;;
        esac
    done
}

# Start replay operation
cmd_run() {
    log_info "Starting C-Chain replay..."
    log_info "Source: $SOURCE_RPC"
    log_info "Target: $RPC"
    log_info "Blocks: $FROM_BLOCK to $TO_BLOCK"

    # Build the RPC request
    REQUEST=$(cat <<EOF
{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "lux_replayStart",
    "params": [{
        "sourceRpc": "$SOURCE_RPC",
        "from": "$FROM_BLOCK",
        "to": "$TO_BLOCK",
        "chainId": $DEFAULT_CHAIN_ID,
        "verifyReceipts": $VERIFY_RECEIPTS,
        "strictStateRoot": $STRICT_STATE,
        "checkpointEvery": $CHECKPOINT_EVERY,
        "receiptWorkers": $RECEIPT_WORKERS,
        "maxInFlightRpc": 128,
        "headerCompat": "auto",
        "persistenceDir": "$DEFAULT_CHECKPOINT_DIR"
    }]
}
EOF
    )

    # Send the request
    RESPONSE=$(curl -s -X POST "$RPC" \
        -H "Content-Type: application/json" \
        --data "$REQUEST")

    # Check response
    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR=$(echo "$RESPONSE" | jq -r '.error.message')
        log_error "Failed to start replay: $ERROR"
        exit 1
    fi

    log_success "Replay started successfully"

    # Tail the progress if requested
    if [ "$TAIL" = true ]; then
        log_info "Following replay progress (Ctrl+C to stop)..."
        tail_progress
    fi
}

# Get replay status
cmd_status() {
    REQUEST='{"jsonrpc":"2.0","id":1,"method":"lux_replayStatus","params":[]}'

    RESPONSE=$(curl -s -X POST "$RPC" \
        -H "Content-Type: application/json" \
        --data "$REQUEST")

    if [ "$JSON_OUTPUT" = true ]; then
        echo "$RESPONSE" | jq '.result'
    else
        # Parse and display status
        if echo "$RESPONSE" | jq -e '.result' > /dev/null 2>&1; then
            STATUS=$(echo "$RESPONSE" | jq -r '.result')

            IS_REPLAYING=$(echo "$STATUS" | jq -r '.replaying // false')
            CURRENT=$(echo "$STATUS" | jq -r '.currentBlock // 0')
            TARGET=$(echo "$STATUS" | jq -r '.targetBlock // 0')
            RATE=$(echo "$STATUS" | jq -r '.blocksPerSecond // 0')

            if [ "$IS_REPLAYING" = "true" ]; then
                PROGRESS=$(awk "BEGIN {printf \"%.2f\", ($CURRENT / $TARGET) * 100}")
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "  Replay Status: ACTIVE"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "  Current Block: $CURRENT / $TARGET"
                echo "  Progress: ${PROGRESS}%"
                echo "  Speed: $RATE blocks/sec"

                if [ "$RATE" != "0" ]; then
                    REMAINING=$((TARGET - CURRENT))
                    ETA=$((REMAINING / RATE))
                    echo "  ETA: $(format_duration $ETA)"
                fi
            else
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "  Replay Status: IDLE"
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "  Last Block: $CURRENT"
            fi
        else
            log_error "Failed to get status"
            exit 1
        fi
    fi
}

# Stop replay operation
cmd_stop() {
    log_info "Stopping replay..."

    REQUEST='{"jsonrpc":"2.0","id":1,"method":"lux_replayStop","params":[]}'

    RESPONSE=$(curl -s -X POST "$RPC" \
        -H "Content-Type: application/json" \
        --data "$REQUEST")

    if echo "$RESPONSE" | jq -e '.result.stopped' > /dev/null 2>&1; then
        log_success "Replay stopped"
    else
        log_error "Failed to stop replay"
        exit 1
    fi
}

# Resume from checkpoint
cmd_resume() {
    log_info "Resuming replay from checkpoint..."

    # Check if checkpoint exists
    if [ ! -f "$DEFAULT_CHECKPOINT_DIR/progress.json" ]; then
        log_error "No checkpoint found at $DEFAULT_CHECKPOINT_DIR/progress.json"
        exit 1
    fi

    # Read checkpoint
    LAST_HEIGHT=$(jq -r '.lastHeight' "$DEFAULT_CHECKPOINT_DIR/progress.json")
    RESUME_FROM=$((LAST_HEIGHT + 1))

    log_info "Resuming from block $RESUME_FROM"

    # Start replay from checkpoint
    FROM_BLOCK="0x$(printf '%x' $RESUME_FROM)"
    cmd_run
}

# Verify blocks
cmd_verify() {
    log_info "Verifying blocks $FROM_BLOCK to $TO_BLOCK..."

    # Convert hex to decimal if needed
    if [[ "$FROM_BLOCK" == 0x* ]]; then
        FROM_DEC=$((FROM_BLOCK))
    else
        FROM_DEC=$FROM_BLOCK
    fi

    if [[ "$TO_BLOCK" == 0x* ]]; then
        TO_DEC=$((TO_BLOCK))
    else
        TO_DEC=$TO_BLOCK
    fi

    ERRORS=0

    for ((i=FROM_DEC; i<=TO_DEC; i++)); do
        HEX_BLOCK="0x$(printf '%x' $i)"

        # Get block from C-Chain
        C_BLOCK=$(curl -s -X POST "$RPC" \
            -H "Content-Type: application/json" \
            --data "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"eth_getBlockByNumber\",\"params\":[\"$HEX_BLOCK\", false]}" \
            | jq '.result')

        # Get block from legacy
        L_BLOCK=$(curl -s -X POST "$SOURCE_RPC" \
            -H "Content-Type: application/json" \
            --data "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"eth_getBlockByNumber\",\"params\":[\"$HEX_BLOCK\", false]}" \
            | jq '.result')

        # Compare key fields
        C_STATE=$(echo "$C_BLOCK" | jq -r '.stateRoot')
        L_STATE=$(echo "$L_BLOCK" | jq -r '.stateRoot')

        if [ "$C_STATE" != "$L_STATE" ]; then
            log_error "State root mismatch at block $i"
            log_error "  C-Chain: $C_STATE"
            log_error "  Legacy:  $L_STATE"
            ERRORS=$((ERRORS + 1))
        fi

        # Show progress
        if [ $((i % 100)) -eq 0 ]; then
            echo -ne "\rVerified: $i / $TO_DEC"
        fi
    done

    echo
    if [ $ERRORS -eq 0 ]; then
        log_success "Verification complete. All blocks match!"
    else
        log_error "Verification failed. $ERRORS mismatches found."
        exit 1
    fi
}

# Tail replay progress
tail_progress() {
    LAST_BLOCK=0

    while true; do
        STATUS=$(curl -s -X POST "$RPC" \
            -H "Content-Type: application/json" \
            --data '{"jsonrpc":"2.0","id":1,"method":"lux_replayStatus","params":[]}' \
            2>/dev/null | jq '.result')

        IS_REPLAYING=$(echo "$STATUS" | jq -r '.replaying // false')
        CURRENT=$(echo "$STATUS" | jq -r '.currentBlock // 0')
        TARGET=$(echo "$STATUS" | jq -r '.targetBlock // 0')
        RATE=$(echo "$STATUS" | jq -r '.blocksPerSecond // 0' | cut -d'.' -f1)

        if [ "$CURRENT" -ne "$LAST_BLOCK" ]; then
            PROGRESS=$(awk "BEGIN {printf \"%.2f\", ($CURRENT / $TARGET) * 100}")
            echo -ne "\r[${GREEN}REPLAY${NC}] Progress: ${PROGRESS}% | Block: $CURRENT / $TARGET | Speed: $RATE blocks/sec    "
            LAST_BLOCK=$CURRENT
        fi

        if [ "$IS_REPLAYING" = "false" ]; then
            echo
            log_success "Replay complete!"
            break
        fi

        sleep 2
    done
}

# Format duration in seconds to human-readable
format_duration() {
    local seconds=$1
    local hours=$((seconds / 3600))
    local minutes=$(( (seconds % 3600) / 60 ))
    local secs=$((seconds % 60))

    if [ $hours -gt 0 ]; then
        printf "%dh %dm %ds" $hours $minutes $secs
    elif [ $minutes -gt 0 ]; then
        printf "%dm %ds" $minutes $secs
    else
        printf "%ds" $secs
    fi
}

# Main execution
main() {
    parse_args "$@"

    case "$COMMAND" in
        run)
            cmd_run
            ;;
        status)
            cmd_status
            ;;
        stop)
            cmd_stop
            ;;
        resume)
            cmd_resume
            ;;
        verify)
            cmd_verify
            ;;
        *)
            show_usage
            ;;
    esac
}

# Run main
main "$@"
// Copyright (C) 2022-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.
package keycmd

import (
	"errors"
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/luxfi/cli/pkg/key"
	"github.com/luxfi/cli/pkg/ux"
	"github.com/luxfi/sdk/models"
	"github.com/spf13/cobra"
)

const (
	forceFlag = "force"
)

var (
	forceCreate bool
	filename    string
)

// validateKeyFormat checks if the key file has a valid format
func validateKeyFormat(filename string) error {
	content, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read key file: %w", err)
	}

	// Check for common key format patterns
	contentStr := string(content)

	// Check for private key patterns
	hasPrivateKey := strings.Contains(contentStr, "PrivateKey-") ||
		strings.Contains(contentStr, "-----BEGIN") ||
		strings.Contains(contentStr, "0x") && len(contentStr) >= 64

	if !hasPrivateKey {
		return fmt.Errorf("file does not appear to contain a valid private key")
	}

	// Check for invalid characters that might indicate a corrupted file
	if strings.ContainsAny(contentStr, "\x00") {
		return fmt.Errorf("file contains null bytes, may be corrupted")
	}

	return nil
}

func createKey(_ *cobra.Command, args []string) error {
	keyName := args[0]

	if match, _ := regexp.MatchString("\\s", keyName); match {
		return errors.New("key name contains whitespace")
	}

	if app.KeyExists(keyName) && !forceCreate {
		return errors.New("key already exists. Use --" + forceFlag + " parameter to overwrite")
	}

	if filename == "" {
		// Create key from scratch
		ux.Logger.PrintToUser("Generating new key...")
		k, err := key.NewSoft(0)
		if err != nil {
			return err
		}
		keyPath := app.GetKeyPath(keyName)
		if err := k.Save(keyPath); err != nil {
			return err
		}
		ux.Logger.PrintToUser("Key created")
		networks := []models.Network{models.Testnet, models.Mainnet}
		cchain := true
		pchain := true
		xchain := false
		var subnets []string
		clients, err := getClients(networks, pchain, cchain, xchain, subnets)
		if err != nil {
			return err
		}
		addrInfos, err := getStoredKeyInfo(clients, networks, keyPath)
		if err != nil {
			return err
		}
		printAddrInfos(addrInfos)
	} else {
		// Load key from file and validate format
		ux.Logger.PrintToUser("Loading user key...")
		// Validate key format before copying
		if err := validateKeyFormat(filename); err != nil {
			return fmt.Errorf("invalid key format: %w", err)
		}
		if err := app.CopyKeyFile(filename, keyName); err != nil {
			return err
		}
		ux.Logger.PrintToUser("Key loaded")
	}

	return nil
}

func newCreateCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "create [keyName]",
		Short: "Create a signing key",
		Long: `The key create command generates a new private key to use for creating and controlling
test Subnets. Keys generated by this command are NOT cryptographically secure enough to
use in production environments. DO NOT use these keys on Mainnet.

The command works by generating a secp256 key and storing it with the provided keyName. You
can use this key in other commands by providing this keyName.

If you'd like to import an existing key instead of generating one from scratch, provide the
--file flag.`,
		Args:         cobra.ExactArgs(1),
		RunE:         createKey,
		SilenceUsage: true,
	}

	cmd.Flags().StringVar(
		&filename,
		"file",
		"",
		"import the key from an existing key file",
	)
	cmd.Flags().BoolVarP(
		&forceCreate,
		forceFlag,
		"f",
		false,
		"overwrite an existing key with the same name",
	)
	return cmd
}
